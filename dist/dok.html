<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Bootstrap CSS -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Bitter:400,700"
    />

    <link rel="stylesheet" href="dok.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js"></script>

    <title>Covid-Zugangskonrolle</title>
  </head>
  <body>
    <div class="container-fluid">
      <div class="row">
        <div class="col">
          <nav id="navbar">
            <ul class="nav flex-column">
              <header>Projekt Dokumentation</header>
              <li class="nav-item">
                <a class="nav-link motivation" href="#Motivation"
                  >1. Motivation der Anwendung</a
                >
              </li>
              <li class="nav-item">
                <a class="nav-link auswahl" href="#Auswahl"
                  >2. Auswahl und Implementation der Sensoren</a
                >
              </li>
              <li class="nav-item">
                <a class="nav-link algorithmus" href="#Algorithmus"
                  >3. Erarbeitung eines geeigneten Algorithmus</a
                >
              </li>
              <li class="nav-item">
                <a class="nav-link implementation" href="#Implementation"
                  >4. Implementation</a
                >
              </li>
              <li class="nav-item">
                <a class="nav-link testen" href="#Testen"
                  >5. Testen der Anwendung</a
                >
              </li>
              <li class="nav-item">
                <a class="nav-link fazit" href="#Fazit">6. Fazit</a>
              </li>
              <li class="nav-item">
                <a class="nav-link anhang" href="#Anhang">Anhang</a>
              </li>
            </ul>
          </nav>
        </div>

        <div class="col-md-9">
          <nav class="navbar navbar-light" style="background-color: #e3f2fd">
            <a class="navbar-brand" href="#">MR Lab Reservationstool</a>
            <button
              class="navbar-toggler"
              type="button"
              data-toggle="collapse"
              data-target="#navbarSupportedContent"
              aria-controls="navbarSupportedContent"
              aria-expanded="false"
              aria-label="Toggle navigation"
            >
              <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarSupportedContent">
              <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                  <a class="nav-link" href="index.html">Startseite</a>
                </li>
                <li class="nav-item" role="presentation">
                  <a class="nav-link" href="dok.html">Dokumentation</a>
                </li>
                <li class="nav-item active">
                  <a class="nav-link" href="/cloud_demo.html">Demo</a>
                </li>
              </ul>
            </div>
          </nav>
          <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
              <li class="breadcrumb-item">
                <a href="/index.html">Startseite</a>
              </li>
              <li class="breadcrumb-item active" aria-current="page">
                Dokumentation
              </li>
            </ol>
          </nav>
          <main id="main-doc">
            <div class="head-box">
              <h1>Covid-19 Zugangskontrolle</h1>
            </div>

            <section class="main-section" id="Motivation">
              <header><h2>1. Motivation der Anwendung</h2></header>
              <article>
                <p>
                  Im ersten Abschnitt dieser Dokumentation wird die Motivation
                  für die Wahl dieses Projekts erläutert. Es wird dabei
                  aufgezeigt, weshalb dieses Projekt gewählt wurde, wie dieses
                  umgesetzt werden kann und was schlussendlich der Nutzen des
                  fertigen Produkts ist.
                </p>
                <h3>1.1 Problembeschreibung</h3>
                <p>
                  Anlass dieses Projekts ist die zum Zeitpunkt dieses
                  leistungsnachweises immer noch anhaltende Covid-19 Pandemie.
                  Aktivitäten können nach dem ersten Lockdown wieder aufgenommen
                  werden jedoch droht bereits der zweite Lockdown. Diese
                  Wiederaufnahme erfolgt nach wie vor unter strengsten
                  Sicherheitsmassnahmen, um das Risiko sich mit Covid-19
                  anzustecken, so gering wie möglich zu halten. Die Idee für
                  dieses Projekt entstand, da an meinem Arbeitsplatz, dem MR Lab
                  an der ZHAW (SW 329) maximal 6 Personen den Raum zur gleichen
                  Zeit betreten dürfen. Auch wenn das Lab online reserviert
                  wird, ist es trotzdem noch möglich den Raum zu betreten. Dies
                  schreit nach einer IoT-Lösung.
                </p>
                <h3>1.2 Lösungsidee</h3>
                <p>
                  Die Lösungsidee besteht aus zwei Lichtsensoren, welche
                  Personen erkennen und zählen und einem Servomotor, welcher den
                  Zugang sperrt, sobald die maximale Anzahl an Personen erreicht
                  ist. Ebenfalls soll jemand im Lab in der Lage sein auf
                  Knopfdruck den Raum zu sperren oder den Status des Labs online
                  über eine Funktion auf besetzt zu setzen und wieder zu öffnen.
                  Auf einem Display, welches an der Türe zum Lab angebracht
                  wird, soll die Anzahl Personen im Raum und die Meldung, ob man
                  den Raum betreten darf oder warten soll, angezeigt werden.
                </p>
                <h3>1.3 Nutzen der Lösung</h3>
                <p>
                  Durch diese Lösung setzen sich Studierende und Dozenten,
                  welche das Lab in Anspruch nehmen, nicht unvorhergesehenen
                  Risiken bezüglich Covid-19 aus. Durch diese Anwendung kann
                  sichergestellt werden, dass die maximale Anzahl Personen im
                  Lab eingehalten wird und die Nutzer somit in der Lage sind
                  genügend Abstand zueinander einzuhalten.
                </p>
              </article>
            </section>

            <section class="main-section" id="Auswahl">
              <header>
                <h2>2. Auswahl und Implementation der Sensoren</h2>
              </header>
              <article>
                <p>
                  Nachfolgend sind sämtliche Sensoren und Aktoren, welche für
                  das Projekt eingesetzt wurden, aufgeführt. Ich gebe hierbei
                  eine kurze Begründung weshalb diese wichtig sind bzw.
                  eingesetzt werden und wie diese mit dem Argon verbunden
                  werden.
                </p>
                <h3>2.1 Servomotor (Micro Servo WAVGAT SG90) – Schranke</h3>
                <p>
                  Zur Erstellung einer Schranke benötigt es einen Servomotor.
                  Der Kopf des Motors bewegt sich bei einer offenen Schranke auf
                  90 Grad und schliesst sich indem die Position auf null Grad
                  gesetzt wird. Die Schranke kann per Knopfdruck oder per
                  Funktion für eine beliebige Anzahl Sekunden geschlossen
                  werden. Ausserdem schliesst sich die Schranke, wenn das Limit
                  von 6 Personen erreicht ist. Der Servomotor wird verbunden mit
                  dem A1-Pin (orange). Auf dem Particle Argon können die Pins
                  D2-D8 und A0-A5 für einen Servomotor verwendet werden. Hier
                  wurde Pin A1 für bessere Übersicht und einfacheres
                  Anschliessen gewählt. Die Stromzufuhr (rot) wurde über den
                  VBUS Pin gewählt. Dieser Pin ist intern mit dem VBUS des
                  USB-Ports verbunden. Der Nennausgang sollte etwa 4,5 bis 5 V
                  betragen, wenn das Gerät an den USB-Port angeschlossen ist,
                  und 0, wenn es nicht an eine USB-Quelle angeschlossen ist.
                  Dieser Pin kann wurde gewählt, da die Spannung des 3V3 Pin für
                  diesen Anwendungsfall nicht ausreichend war. Der Nennstrom des
                  USB-Ports, der nominell auf 500 mA festgelegt ist, sollte
                  nicht überschritten werden. Dieser Pin ist mit einer internen
                  Sicherung geschützt, die auf 1000 mA ausgelegt ist.
                  Schliesslich wird das dritte Kabel (braun) mit dem GND-Pin
                  (ground) verbunden. GND ist dort, wo das elektrische Niveau
                  bei null Volt liegt. Es wird meist als Referenz für alle
                  anderen elektronischen Bauteile verwendet, denn sie benötigen
                  einen gemeinsamen Punkt, um korrekt zusammen zu arbeiten.
                </p>
                <p>
                  Damit der Servomotor benutzt werden kann muss ein Servo-Objekt
                  erstellt werden:
                </p>

                <pre>
        <code>
            Servo myservo;  // create servo object to control a servo</code>
      </pre>

                <p>
                  Es wird eine Variable
                  <code class="highlight-rouge">int position = 90;</code>
                  deklariert, um später hiermit die Position des Servos
                  auszulesen. Liegt die Position bei 90 Grad, bedeutet das die
                  Schranke ist geöffnet. Bei 0 Grad ist die Schranke
                  geschlossen. Beim Setup wird angegeben, auf welchem Pin sich
                  der Servo befindet, um mit dem Servo-Objekt zu kommunizieren.
                </p>

                <pre>
        <code>
            myservo.attach(A1);  // attaches the servo on pin A1 to the servo object</code>
      </pre>
                <p>
                  Die Position des Servos kann direkt mit einer Zahl oder mit
                  der Variable «position» festgelegt werden.
                </p>

                <pre>
<code>
    myservo.write(position); oder myservo.write(90);</code>
</pre>

                <h3>
                  2.2 OLED-Display (SSD1306 128x64 I2C) – Informationsanzeige
                </h3>
                <p>
                  Zur Information von Personen, welche den Raum betreten
                  möchten, wird ein OLED-Display aufgehängt, welches die
                  wichtigsten Informationen anzeigt.
                </p>
                <p>
                  Wenn die Schranke geschlossen ist, wird «Bitte warten…», die
                  Anzahl Personen im Raum und ein Icon angezeigt. Bei einer
                  offenen Schranke wird ebenfalls die Anzahl Personen, ein Icon
                  und der Text «Bitte eintreten.» angezeigt. I2C, auch als I2C
                  geschrieben und I-squared-C ausgesprochen, ist eine Methode
                  zur Kommunikation zwischen Geräten wie Sensoren, Displays und
                  anderen Peripheriegeräten und einem Mikrocontroller wie dem
                  Argon. 0,96" OLED I2C-Displays sind preiswert und einfach zu
                  bedienen. Das gewählte Display ist mit dem SSD1306 kompatibel
                  und hat eine Auflösung von 128x64 Pixeln.
                </p>
                <p>
                  Die Kommunikation erfordert zwei Leitungen, SDA und SCL. Die
                  meisten Geräte benötigen außerdem Strom und Masse, so dass in
                  der Regel vier Leitungen erforderlich sind. In der
                  I2C-Terminologie ist das Partikel-Gerät (Argon, usw.) das
                  I2C-Master-Gerät und alle anderen Geräte (Sensoren, Displays
                  usw.) sind I2C-Slave-Geräte. Die SDA (Daten)-Leitung wird
                  verwendet, um Daten sowohl zu als auch von den I2C-Geräten zu
                  senden. Das I2C-Protokoll bestimmt, in welche Richtung Daten
                  gesendet werden. Die SCL (Takt)-Leitung wird vom Argon
                  erzeugt, obwohl sie auch bidirektional ist, wenn die
                  Taktdehnung verwendet wird.
                </p>
                <p>
                  Ganz rechts ist der GND-Pin. Der VCC Pin steht für die
                  Stromversorgung des Displays. In diesem Falle benötigen wir
                  wiederum 5V, was wir vom VBUS beziehen, wie vorhin beim
                  Servomotor. Die SCL und SDA Anschlüsse am Display werden mit
                  den Pins D0 und D1 verbunden. Auf dem Argon besteht ebenfalls
                  die Möglichkeit mehrere Displays gleichzeitig zu verbinden, da
                  hierbei, im Gegensatz zu anderen Particle-Geräten, SCL und SDA
                  ebenfalls mit den Pins D2 und D3 verbunden werden können.
                </p>
                <h3>2.3 Zwei Adafruit IR Break Beam Sensoren</h3>
                <p>
                  Zur Erkennung und Zählung der Personen, welche den Raum
                  betreten oder verlassen, werden die beiden IR Break Beam
                  Sensoren des Lichtschranken-Projekts verwendet. Für den ersten
                  Sensor wird der D6 Pin und für den zweiten der D5 Pin
                  verwendet. Wird hierbei also zuerst der Pin D6 durchtrennt und
                  anschliessend der Pin D5 wissen wir, dass eine Person den Raum
                  betritt. Dies wiederum erhöht den Counter um 1. Wird zuerst
                  der Pin D5 und dann D6 durchtrennt, verlässt eine Person den
                  Raum, was den Counter um 1 verringert. Beides mal wird die
                  Anzahl Personen laufend auf dem OLED-Display aktualisiert.
                </p>
                <h3>2.4 Verkabelung</h3>
                <p>
                  <img
                    src="images/verkabelung.JPG"
                    class="rounded mx-auto d-block"
                    alt="Verkabelung"
                  />
                </p>
                <h3>2.5 Sammlung und Auswertung der Messdaten</h3>
                <p>
                  Die Ein- und Ausgangsdaten werden, wie unter 2.3 beschrieben,
                  durch die zwei IR Break Beam Sensoren gesammelt und in einer
                  «counter» Variable gespeichert. Tritt jemand in den Raum ein
                  wird dem Counter 1 hinzugefügt. Beim Austritt einer Person
                  wird vom Counter 1 subtrahiert.
                </p>
                <p>
                  Erreicht der Counter eine Anzahl von 6, was das Limit des MR
                  Labs ist, schliesst sich die Schranke automatisch. Die
                  Schranke öffnet sich wieder sobald ein Wert unter 6 erreicht
                  wurde.
                </p>
                <p>
                  Auch das OLED-Display reagiert auf die im Counter angegebene
                  Anzahl Personen. Sobald 6 Personen erreicht werden, hat es im
                  MR Lab keinen Platz mehr. Das OLED-Display, welches vor dem
                  Zimmer SW329 angebracht werden soll, signalisiert somit
                  jederzeit wie viel Freie Plätze es im Raum hat. Dabei wird die
                  im Counter Anzahl von der Maximalanzahl an Personen abgezogen.
                </p>
                <pre>
                  <code>
                    display.println(6-counter);</code>
                  </pre>
                <p><img src="images/plaetze.JPG" alt="Plaetze" /></p>
                <p>
                  Das gleiche Resultat kann erreicht werden durch das Drücken
                  des Knopfes. Wird der Knopf gehalten schliesst die Schranke
                  und das OLED-Display zeigt an, dass der Raum voll ist.
                </p>
                <p>
                  Events werden auf dem Frontend direkt in einer Tabelle
                  gesammelt und können sogleich exportiert und analysiert
                  werden.
                </p>
              </article>
            </section>
            <section class="main-section" id="Algorithmus">
              <header>
                <h2>3. Erarbeitung eines geeigneten Algorithmus</h2>
              </header>
              <article>
                <p>
                  Untenstehend finden Sie den gesamten Code der Particle-App.
                  Der Code wurde mithilfe der Particle Web IDE erstellt. Die
                  wichtigsten Stellen des Codes sind direkt kommentiert:
                </p>
                <script src="https://gist.github.com/covierob/4e5e1d27d27f45d0f06b6e04deb2d2ac.js"></script>
                <p>
                  Damit das OLED-Display funktioniert muss zunächst die Library
                  «Adafruit_SSD1306_RK.h» importiert werden. Dies geschieht im
                  Particle über den «#include»-Befehl.
                </p>
                <p>
                  Danach werden die Variablen (Sensoren) den Pins auf dem Argon
                  zugeordnet. Als nächstes werden booleans deklariert, mithilfe
                  derer später überprüft werden kann, ob und welcher IR Break
                  Beam durchtrennt wurde und somit auf die richtige Methode
                  geleitet wird. Wird ein IR Sensor durchtrennt wird der bool
                  «waitToConfirm» auf «true» gesetzt, damit der Algorithmus
                  weiss, dass darauf gewartet werden muss, bis der zweite Sensor
                  durchtrennt wurde.
                </p>
                <p>
                  Anschliessend wird die Funktion «raumReservieren» erstellt,
                  mit welcher später im Frontend die Schranke für die gewünschte
                  Zeit gesperrt werden kann. Das OLED-Display benötigt eine
                  «updateDisplay» Funktion, um den neu anzuzeigenden Text zu
                  laden. Mithilfe von «Adafruit_SSD1306 display…» werden
                  Dimensionen des OLED-Displays gesetzt. In diesem Falle ist
                  dies 128x64 Pixel.
                </p>
                <p>
                  In der Setup-Funktion wird zunächst das OLED-Display
                  aktiviert. Der «pinMode» für den Button, die beiden IR
                  Sensoren und das LED werden gesetzt. Die Particle Variablen
                  «counter» und «position» und die Particle Funktion
                  «raumReservieren» werden erstellt. Schlussendlich wird der
                  Servomotor auf Pin A1 befestigt.
                </p>
                <p>
                  Zu Beginn wird das OLED-Display auf «Willkommen. Anzahl
                  Personen: ‘counter’» gestellt. Befinden sich mehr als 5
                  Personen im Raum, also übersteigt der Counter die Zahl 5, oder
                  wird der Button gedrückt, schliesst sich die Schranke, indem
                  die Position auf 0 gesetzt wird und das OLED-Display zeigt den
                  Text «Raum voll». Solange die Schranke geöffnet ist, also
                  weder der Knopf gedrückt wird oder der Counter über 5 ist,
                  wird «Platz frei. Anzahl freie Plätze: ‘counter’» angezeigt.
                  Gleiches geschieht, wenn die Funktion «raumReservieren»
                  aufgerufen wird. Die Schranke wird für die angegebene Anzahl
                  Sekunden geschlossen und auch das OLED-Display regiert erneut
                  dementsprechend. Die Schranke öffnet sich und das OLED-Display
                  ändert sich wieder zurück nach Ablauf der Anzahl Sekunden.
                </p>
                <p>
                  In der Loop-Funktion, wenn der IR Sensor A zuerst durchtrennt
                  wird, wird die SensorID 0 an die Funktion «sensorBreak»
                  weitergegeben. Diese setzt den LED Pin auf HIGH, setzt den
                  bool «waitToConfirm» auf «true» und gibt die SensorID 1 an die
                  Funktion «sensorConfirm» weiter. Wird der 2. Sensor nun
                  durchtrennt, wird der LED Pin wieder auf LOW, der IR Status
                  auf «false» und «waitToConfirm» auf «false» gesetzt, der
                  Counter wird um 1 erhöht und das Event «motionDetected» wird
                  ausgelöst. In diesem Falle «Person eingegangen», im
                  umgekehrten Fall «Person ausgegangen» wobei der Counter wieder
                  um 1 reduziert wird.
                </p>
              </article>
            </section>
            <section class="main-section" id="Implementation">
              <header><h2>4. Implementation</h2></header>
              <article>
                <p>
                  Als Ausgangslage wurde der zur Verfügung gestellt Backend-Code
                  und das im Rahmen der Gruppenarbeit entwickelte Sensorprojekt
                  verwendet.
                </p>
                <h3>4.1 Daten aggregieren und analysieren</h3>
                <p>Text</p>
                <h3>4.2 Übermittlung der Daten vom Argon zum Backend</h3>
                <p>Text</p>
                <h3>4.3 Kommunikation zwischen Frontend und Backend</h3>
                <p>
                  Demo starten indem Anzahl Sekunden angegeben wird.
                  OLED-Display zeigt an wie viele Sekunden (in realem Umfeld
                  wären es Minuten oder Stunden) die Demo läuft.
                </p>
                <h3>4.4 Visualisierung der Daten</h3>
                <p>
                  Online soll die Verfügbarkeit abgerufen werden sollen. Ist die
                  Schranke geöffnet und somit mindestens ein Arbeitsplatz frei,
                  soll hierbei «Bitte treten Sie ein!» angezeigt werden. Ist der
                  Raum besetzt wird «Der Raum ist zurzeit leider besetzt!»
                  angezeigt.
                </p>
              </article>
            </section>

            <section class="main-section" id="Testen">
              <header><h2>5. Testen der Anwendung</h2></header>
              <article>
                <p>
                  Aufgrund der derzeitigen Situation ist es nicht möglich diesen
                  Prototypen tatsächlich vor Ort im MR Lab zu testen.
                  Nachfolgend wird ein hypothetisches Szenario beschrieben, wie
                  dieser Prototyp eingesetzt werden könnte. Zum Test dieser
                  Anwendung wurde eine Vorrichtung aus Karton gebastelt. Eine
                  Demonstration des Tests kann auf der
                  <a href="http://localhost:3001/index.html">Startseite</a> des
                  Frontend gefunden werden.
                </p>
                <h3>
                  5.1 Erarbeiten eines Testkonzepts und Durchführung der Tests
                </h3>
                <p>
                  Der Test dieser Anwendung ist im Grunde genommen sehr simpel.
                  Die beiden IR Break Beam Sensoren werden an der Türe
                  befestigt. Sensor 1 wird dabei einige Zentimeter vor Sensor 2
                  platziert. Somit kann erkannt werden, welcher Sensor zuerst
                  durchtrennt wurde. Wurde zuerst Sensor 1 durchtrennt und dann
                  Sensor 2 hat eine Person den Raum betreten. Wird Sensor 2 und
                  dann Sensor 1 durchtrennt hat eine Person den Raum verlassen.
                </p>
                <p>
                  Der Knopf sollte sich am Platz des Dozenten befinden. Wenn
                  dieser gedrückt wird sollte sich die Schranke schliessen und
                  somit der Zutritt zum Lab unterbrochen werden.
                </p>
                <p>
                  Vor der Türe zum Zimmer SW329 sollte das OLED-Display
                  angebracht werden, welches ständig den Zustand des Raumes und
                  die Anzahl an freien Arbeitsplätzen anzeigt.
                </p>
                <p>
                  Wenn der Counter die Zahl 5 übersteigt muss sich die Schranke
                  schliessen und sofort wieder öffnen sobald die Zahl 5 oder
                  tiefer erreicht wird.
                </p>
                <p>
                  Untenstehende Abbildung zeigt die Vorrichtung, welche zu
                  Testzwecken entworfen wurde.
                </p>
                <p>
                  <img
                    src="images/testing.jpg"
                    class="rounded mx-auto d-block"
                    alt="Test"
                  />
                </p>
                <h3>5.2 Testergebnisse auswerten und dokumentieren</h3>
                <p>Text</p>
              </article>
            </section>

            <section class="main-section" id="Fazit">
              <header><h2>6. Fazit</h2></header>
              <article>
                <p>Text</p>
                <h3>6.1 Learnings</h3>
                <p>
                  Das Setup des OLED-Displays bereitete mir zu Beginn grosse
                  Probleme, da der Vorgang nicht gleich wie beim Arduino ist und
                  es zu Particle-Geräten nur wenige Ressourcen gibt. Ich habe
                  jedoch ein paar wenige, sehr hilfreiche Ressourcen gefunden,
                  welche ich hier teilen möchte. Eine gute Erklärung bietet
                  <a
                    href="https://docs.particle.io/tutorials/learn-more/about-i2c/"
                    >Particle</a
                  >
                  selbst. Hierbei ist jedoch nicht genau ersichtlich wie man nur
                  das Display einbindet und in Gang bringt. Es muss also erst
                  viel herumexperimentiert werden. Eine sehr gute Erklärung
                  bietet «rickkas7» auf Github, mit
                  <a
                    href="https://github.com/rickkas7/SSD1306-tutorial/blob/master/firmware/Logo_128x64_I2C/src/Logo.cpp"
                    >Beispiel-Dateien</a
                  >
                  und sogar einem
                  <a href="https://rickkas7.github.io/DisplayGenerator/"
                    >Display-Generator</a
                  >
                  . Dieser Display-Generator ermöglicht einem den exakten Code,
                  welchen man in seine Anwendung setzen will, zu generieren,
                  inklusive Bitmaps für die Icons. Diese Ressourcen haben für
                  mich funktioniert und waren sehr einfach einzubinden.
                </p>
                <h3>6.2 Ausblick</h3>
                <p>Text</p>
              </article>
            </section>

            <section class="main-section" id="Anhang">
              <header><h2>Anhang</h2></header>
              <article>
                <p>Text</p>
                <h3>Frontend und Backend Code</h3>
                <p>Text</p>
                <h3>Particle-App</h3>
                <p>Text</p>
              </article>
            </section>
          </main>

          <hr />
          <footer>
            <div class="contact">
              <a
                href="https://github.com/covierob/covid-lichtschranke-cove"
                target="_blank"
              >
                <span class="icon"><i class="fa fa-github"></i></span
              ></a>
              <a
                href="https://www.linkedin.com/in/robertocoviello/"
                target="_blank"
              >
                <span class="icon"><i class="fa fa-linkedin"></i></span
              ></a>
            </div>
            <p>
              Roberto Coviello | <a href="mailto:cove@zhaw.ch">cove@zhaw.ch</a>
            </p>
          </footer>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.bundle.min.js"></script>

    <style>
      .top-scrollerx {
        position: fixed;
        bottom: 100px;
        right: 10px;
        font-size: 1em;
        display: none;
        z-index: 999;
        text-align: center;
        cursor: pointer;
        height: 40px;
        width: 40px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.35);
        color: #fff;
        line-height: 40px;
      }
      .top-scrollerx:hover {
        background: rgba(0, 0, 0, 0.6);
      }
    </style>
    <div class="top-scrollerx js-top-scrollerx svg-icons">
      <svg
        style="vertical-align: text-bottom"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 448 512"
        data-fa-i2svg=""
      >
        <path
          fill="currentColor"
          d="M6.101 261.899L25.9 281.698c4.686 4.686 12.284 4.686 16.971 0L198 126.568V468c0 6.627 5.373 12 12 12h28c6.627 0 12-5.373 12-12V126.568l155.13 155.13c4.686 4.686 12.284 4.686 16.971 0l19.799-19.799c4.686-4.686 4.686-12.284 0-16.971L232.485 35.515c-4.686-4.686-12.284-4.686-16.971 0L6.101 244.929c-4.687 4.686-4.687 12.284 0 16.97z"
        ></path>
      </svg>
    </div>
    <script>
      $(window).scroll(function () {
        // console.log('wwww');
        if ($(this).scrollTop() > 400) {
          $(".js-top-scrollerx").fadeIn();
        } else {
          $(".js-top-scrollerx").fadeOut();
        }
      });
      //Click event to scroll to top
      $(".js-top-scrollerx").click(function () {
        $("html, body").animate({ scrollTop: 0 }, 1000);
        return false;
      });
    </script>
  </body>
</html>
